apiVersion: state-machine.converged-computing.org/v1alpha1
kind: StateMachine
metadata:
  name: state-machine
spec:
  manager:
    pullPolicy: Never
    interactive: true
  workflow:
    completed: 10

    events:
      # Custom metric - derived from parsing lammps log
      - metric: mean.lammps.lammps-walltime
        when: ">= 12"
        action: grow
        # Size 4 cluster, max decreases down to 1
        repetitions: 3
        # Require checks between before doing again
        # TODO check if this is working correctly.
        # also check the .get()
        backoff: 3
        maxSize: 10

  cluster:
    maxSize: 2

  jobs:
  - name: job_a
    config:
      nodes: 1
      coresPerTask: 1
    image: rockylinux:9
    script: echo This is a setup for lammps

  # Note that this step always fails and we never make it to C
  # This should end the workflow early
  - name: lammps
    properties:
      minicluster: "yes"
    config:
      nodes: 4
      # coresPerTask: 1
    image: ghcr.io/converged-computing/metric-lammps-cpu:zen4
    workdir: /opt/lammps/examples/reaxff/HNS/
    # TODO we need a way for this to include flux and get cores in instance on demand
    script: lmp -v x 2 -v y 2 -v z 2 -in ./in.reaxff.hns -nocite

    # Event parsing. Assume for a log for now
    events:
     script: |
        def parse_log(log):
            import re
            match = re.search('Total wall time: (?P<walltime>.*)', log)
            walltime = match.groupdict()['walltime']
            hours, minutes, seconds = walltime.split(':')
            walltime = (float(hours) * 60 * 60) + (float(minutes) * 60) + (float(seconds))
            return {"lammps-walltime": walltime}

  - name: job_c
    config:
      nodes: 1
      coresPerTask: 1
    image: rockylinux:9
    script: echo This is the third
